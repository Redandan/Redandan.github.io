<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é€£æ¥éŒ¢åŒ… - Agora Market</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      transition: background-color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: #1a1a1a;
      }
    }

    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08);
      max-width: 500px;
      width: 100%;
      padding: 0;
      overflow: hidden;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .container {
        background: #2a2a2a;
        box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
      }
    }

    /* é¡µé¢å®¹å™¨ */
    .page {
      display: none;
      padding: 32px;
    }

    .page.active {
      display: block;
    }

    /* æ ‡é¢˜åŒºåŸŸ */
    .page-header {
      text-align: center;
      margin-bottom: 32px;
    }

    .page-title {
      font-size: 24px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 8px;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .page-title {
        color: #ffffff;
      }
    }

    .page-subtitle {
      font-size: 14px;
      color: #666;
      line-height: 1.5;
      margin-bottom: 8px;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .page-subtitle {
        color: #b0b0b0;
      }
    }

    .page-description {
      font-size: 14px;
      color: #999;
      line-height: 1.5;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .page-description {
        color: #888;
      }
    }

    /* åŒºå—æ ‡é¢˜ */
    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 12px;
      margin-top: 24px;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .section-title {
        color: #ffffff;
      }
    }

    .section-title:first-child {
      margin-top: 0;
    }

    /* é’±åŒ…æŒ‰é’®åˆ—è¡¨ */
    .wallet-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 24px;
    }

    .wallet-button {
      display: flex;
      align-items: center;
      padding: 16px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      position: relative;
    }

    @media (prefers-color-scheme: dark) {
      .wallet-button {
        background: #333;
        border-color: #444;
      }
    }

    .wallet-button:hover {
      border-color: #3b99fc;
      background: #f5f9ff;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 153, 252, 0.1);
    }

    @media (prefers-color-scheme: dark) {
      .wallet-button:hover {
        background: #3a3a3a;
        border-color: #3b99fc;
        box-shadow: 0 2px 8px rgba(59, 153, 252, 0.2);
      }
    }

    .wallet-button:active {
      transform: translateY(0);
    }

    .wallet-icon {
      width: 28px;
      height: 28px;
      font-size: 28px;
      margin-right: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wallet-info {
      flex: 1;
    }

    .wallet-name {
      font-size: 17px;
      font-weight: 500;
      color: #1a1a1a;
      margin-bottom: 2px;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .wallet-name {
        color: #ffffff;
      }
    }

    .wallet-badge {
      display: inline-block;
      font-size: 12px;
      color: #4caf50;
      background: #e8f5e9;
      padding: 2px 8px;
      border-radius: 4px;
      margin-left: 8px;
    }

    .wallet-type {
      font-size: 14px;
      color: #999;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .wallet-type {
        color: #888;
      }
    }

    /* ä¸»è¦CTAæŒ‰é’® */
    .primary-button {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #3b99fc 0%, #2e7ce8 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 17px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 24px;
    }

    .primary-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 153, 252, 0.3);
    }

    .primary-button:active {
      transform: translateY(0);
    }

    .primary-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* QR Code é¡µé¢ */
    .qr-container {
      text-align: center;
      margin: 32px 0;
    }

    .qr-box {
      width: 260px;
      height: 260px;
      margin: 0 auto;
      padding: 20px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .qr-box {
        background: #333;
        border-color: #444;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
    }

    #qrcode {
      width: 100%;
      height: 100%;
    }

    .qr-expiry {
      font-size: 12px;
      color: #999;
      margin-top: 12px;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .qr-expiry {
        color: #888;
      }
    }

    .qr-refresh {
      margin-top: 16px;
      background: none;
      border: 1px solid #e0e0e0;
      color: #666;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    @media (prefers-color-scheme: dark) {
      .qr-refresh {
        border-color: #444;
        color: #b0b0b0;
      }
    }

    .qr-refresh:hover {
      border-color: #3b99fc;
      color: #3b99fc;
    }

    .qr-steps {
      text-align: left;
      margin-top: 32px;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 12px;
    }

    .qr-steps-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 12px;
    }

    .qr-steps-list {
      list-style: none;
      padding: 0;
    }

    .qr-steps-list li {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
      padding-left: 24px;
      position: relative;
    }

    .qr-steps-list li:before {
      content: counter(step);
      counter-increment: step;
      position: absolute;
      left: 0;
      width: 20px;
      height: 20px;
      background: #3b99fc;
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
    }

    .qr-steps-list {
      counter-reset: step;
    }

    .wallet-icons {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 16px;
      flex-wrap: wrap;
    }

    .wallet-icon-small {
      width: 32px;
      height: 32px;
      font-size: 32px;
    }

    /* Deep Link é¡µé¢ */
    .deeplink-container {
      text-align: center;
      margin: 32px 0;
    }

    .deeplink-icon {
      width: 64px;
      height: 64px;
      font-size: 64px;
      margin: 0 auto 24px;
    }

    .deeplink-button {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #3b99fc 0%, #2e7ce8 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 17px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 24px;
    }

    .deeplink-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 153, 252, 0.3);
    }

    .deeplink-download {
      margin-top: 24px;
      font-size: 14px;
      color: #666;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .deeplink-download {
        color: #b0b0b0;
      }
    }

    .deeplink-download a {
      color: #3b99fc;
      text-decoration: none;
    }

    .deeplink-download a:hover {
      text-decoration: underline;
    }

    /* è¿”å›æŒ‰é’® */
    .back-button {
      background: none;
      border: none;
      color: #3b99fc;
      font-size: 14px;
      cursor: pointer;
      padding: 8px 0;
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 24px;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .back-button {
        color: #64b5f6;
      }
    }

    .back-button:hover {
      text-decoration: underline;
    }

    /* çŠ¶æ€æç¤º */
    .status {
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
      display: none;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .status.info {
      background: #e3f2fd;
      color: #1976d2;
      display: block;
    }

    @media (prefers-color-scheme: dark) {
      .status.info {
        background: #1e3a5f;
        color: #64b5f6;
      }
    }

    .status.success {
      background: #e8f5e9;
      color: #388e3c;
      display: block;
    }

    @media (prefers-color-scheme: dark) {
      .status.success {
        background: #1b5e20;
        color: #81c784;
      }
    }

    .status.error {
      background: #ffebee;
      color: #d32f2f;
      display: block;
    }

    @media (prefers-color-scheme: dark) {
      .status.error {
        background: #5f1a1a;
        color: #e57373;
      }
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #3b99fc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* é’±åŒ…ä¿¡æ¯æ˜¾ç¤º */
    .wallet-info-display {
      margin-top: 20px;
      padding: 16px;
      background: #f9f9f9;
      border-radius: 8px;
      display: none;
      transition: background-color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .wallet-info-display {
        background: #333;
      }
    }

    .wallet-address {
      font-family: monospace;
      font-size: 14px;
      color: #333;
      word-break: break-all;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .wallet-address {
        color: #ffffff;
      }
    }

    /* Fallback åŒºåŸŸ */
    .fallback-section {
      margin-top: 32px;
      padding-top: 24px;
      border-top: 1px solid #e0e0e0;
      transition: border-color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .fallback-section {
        border-top-color: #444;
      }
    }

    .fallback-text {
      font-size: 14px;
      color: #999;
      margin-bottom: 16px;
      text-align: center;
      transition: color 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
      .fallback-text {
        color: #888;
      }
    }
  </style>
  <!-- QRCode.js for generating QR codes (local) -->
  <script src="qrcode.min.js"></script>
  <!-- WalletConnect Sign Client v2 (æœ¬åœ°æ–‡ä»¶) -->
  <script src="walletconnect-sign-client.js"></script>
</head>
<body>
  <div class="container">
    <!-- çŠ¶æ€æç¤º -->
    <div id="status" class="status info" style="display: none;">
      <span class="loading"></span>
      <span id="statusText">æ­£åœ¨åˆå§‹åŒ–...</span>
    </div>

    <!-- é¡µé¢ 1: é’±åŒ…é€‰æ‹©å™¨ä¸»é¡µé¢ -->
    <div id="pageSelector" class="page active">
      <div class="page-header">
        <h1 class="page-title">Connect Your Wallet</h1>
        <p class="page-subtitle">é€£æ¥ä½ çš„éŒ¢åŒ…ä»¥ç¹¼çºŒä½¿ç”¨ Agora ç¤¾ç¾¤å•†åŸ</p>
        <p class="page-description">æˆ‘å€‘å°‡ç”¨ä½ çš„éŒ¢åŒ…åœ°å€å»ºç«‹å®‰å…¨ç™»å…¥ã€‚ä½ ä¸éœ€è¦æä¾›ä»»ä½•å¯†ç¢¼ã€‚</p>
      </div>

      <!-- å·²å®‰è£çš„éŒ¢åŒ… -->
      <div id="installedWalletsSection" style="display: none;">
        <div class="section-title">å·²å®‰è£çš„éŒ¢åŒ…ï¼ˆæ¨è–¦ï¼‰</div>
        <div id="installedWalletsList" class="wallet-list"></div>
      </div>

      <!-- æ‰‹æ©ŸéŒ¢åŒ…ç™»å…¥ -->
      <div id="mobileWalletsSection" style="display: none;">
        <div class="section-title">æ‰‹æ©ŸéŒ¢åŒ…ç™»å…¥</div>
        <div id="mobileWalletsList" class="wallet-list"></div>
      </div>

      <!-- å†·éŒ¢åŒ… / QR éŒ¢åŒ…ç™»å…¥ -->
      <div id="coldWalletsSection" style="display: none;">
        <div class="section-title">å†·éŒ¢åŒ… / æƒæç™»å…¥</div>
        <div id="coldWalletsList" class="wallet-list"></div>
      </div>

      <!-- Fallback: WalletConnect -->
      <div class="fallback-section">
        <p class="fallback-text">è‹¥ä»¥ä¸Šæ–¹å¼çš†ç„¡æ³•ä½¿ç”¨ï¼Œä½ ä»å¯ä½¿ç”¨ WalletConnect æƒæç™»å…¥ï¼š</p>
        <button class="primary-button" onclick="showQRPage()">
          <span>ä½¿ç”¨ WalletConnect æƒæç™»å…¥</span>
        </button>
      </div>
    </div>

    <!-- é¡µé¢ 2: QR æ‰«æç™»å½• -->
    <div id="pageQR" class="page">
      <div class="page-header">
        <h1 class="page-title">ä½¿ç”¨éŒ¢åŒ…æƒæä»¥ç™»å…¥</h1>
        <p class="page-subtitle">Scan with WalletConnect</p>
        <p class="page-description">æ”¯æ´æ‰€æœ‰ EVM èˆ‡ TRON éŒ¢åŒ…ï¼ˆTronLink / OKX / Bitget / Trust / SafePalï¼‰</p>
      </div>

      <div class="qr-container">
        <div class="qr-box" id="qrcodeContainer">
          <div id="qrcode"></div>
        </div>
        <div class="qr-expiry" id="qrExpiry">æ­¤ QR å°‡åœ¨ 2 åˆ†é˜å¾ŒéæœŸ</div>
        <button class="qr-refresh" onclick="refreshQRCode()">ğŸ”„ é‡æ–°æ•´ç† QR</button>
      </div>

      <div class="qr-steps">
        <div class="qr-steps-title">ä½¿ç”¨æ­¥é©Ÿï¼š</div>
        <ol class="qr-steps-list">
          <li>æ‰“é–‹ä½ çš„éŒ¢åŒ… App</li>
          <li>æ‰¾åˆ°ã€Œæƒæ QRã€åŠŸèƒ½</li>
          <li>æƒæä»¥å»ºç«‹é€£ç·š</li>
        </ol>
      </div>

      <div class="wallet-icons">
        <span class="wallet-icon-small">ğŸ¦Š</span>
        <span class="wallet-icon-small">ğŸ”´</span>
        <span class="wallet-icon-small">ğŸŸ¢</span>
        <span class="wallet-icon-small">ğŸ’¼</span>
        <span class="wallet-icon-small">ğŸ›¡ï¸</span>
        <span class="wallet-icon-small">ğŸ¯</span>
      </div>

      <button class="back-button" onclick="showSelectorPage()">
        â† è¿”å›éŒ¢åŒ…é¸æ“‡å™¨
      </button>
    </div>

    <!-- é¡µé¢ 3: Deep Link ç™»å½• -->
    <div id="pageDeepLink" class="page">
      <div class="page-header">
        <div class="deeplink-icon" id="deeplinkIcon">ğŸ”´</div>
        <h1 class="page-title" id="deeplinkTitle">æ­£åœ¨æ‰“é–‹ TronLinkâ€¦</h1>
        <p class="page-subtitle" id="deeplinkSubtitle">å¦‚æœæ²’æœ‰è‡ªå‹•è·³è½‰ï¼Œè«‹æ‰‹å‹•é»æ“Šä¸‹æ–¹æŒ‰éˆ•ã€‚</p>
      </div>

      <div class="deeplink-container">
        <button class="deeplink-button" id="deeplinkButton" onclick="openDeepLinkApp()">
          æ‰“é–‹ TronLink App
        </button>

        <div class="deeplink-download" id="deeplinkDownload" style="display: none;">
          æ²’æœ‰å®‰è£ TronLinkï¼Ÿ <a href="#" id="deeplinkDownloadLink" target="_blank">å‰å¾€ä¸‹è¼‰</a>
        </div>
      </div>

      <button class="back-button" onclick="showSelectorPage()">
        â† è¿”å›éŒ¢åŒ…é¸æ“‡å™¨
      </button>
    </div>

    <!-- é’±åŒ…ä¿¡æ¯æ˜¾ç¤º -->
    <div id="walletInfo" class="wallet-info-display">
      <div>å·²é€£æ¥éŒ¢åŒ…ï¼š</div>
      <div class="wallet-address" id="walletAddress"></div>
    </div>
  </div>

  <script>
    // é…ç½®
    const CONFIG = {
      projectId: '7412eb629501759c091220ccc09ded23',
      apiBaseUrl: 'https://agoramarketapi.purrtechllc.com/api',
      supportedChains: ['eip155:1', 'eip155:56'],
    };

    // æ—¥å¿—çº§åˆ«æ§åˆ¶
    const DEBUG = false;
    
    function debugLog(...args) {
      if (DEBUG) console.log(...args);
    }
    
    function debugError(...args) {
      console.error(...args);
    }
    
    function debugWarn(...args) {
      if (DEBUG) console.warn(...args);
    }

    // å…¨å±€å˜é‡
    let signClient = null;
    let session = null;
    let currentUri = null;
    let SignClient = null;
    let isBrowserExtension = false;
    let ethereumProvider = null;
    let isTronLink = false;
    let tronWeb = null;
    let currentDeepLinkWallet = null;
    let qrRefreshTimer = null;

    // é’±åŒ…é…ç½®
    const WALLET_CONFIG = {
      installed: [
        { id: 'metamask', name: 'MetaMask', icon: 'ğŸ¦Š', type: 'extension', installUrl: 'https://metamask.io/download/' },
        { id: 'coinbase', name: 'Coinbase Wallet', icon: 'ğŸ”·', type: 'extension', installUrl: 'https://www.coinbase.com/wallet' },
        { id: 'okx', name: 'OKX Wallet', icon: 'ğŸŸ¢', type: 'extension', installUrl: 'https://www.okx.com/web3' },
        { id: 'tronlink', name: 'TronLink', icon: 'ğŸ”´', type: 'tron', installUrl: 'https://www.tronlink.org/' },
        { id: 'trust', name: 'Trust Wallet', icon: 'ğŸ›¡ï¸', type: 'extension', installUrl: 'https://trustwallet.com/browser-extension' },
        { id: 'bitget', name: 'Bitget Wallet', icon: 'ğŸ’¼', type: 'extension', installUrl: 'https://web3.bitget.com/' },
      ],
      mobile: [
        { id: 'metamask-mobile', name: 'MetaMask Mobile', icon: 'ğŸ¦Š', deepLink: 'metamask://wc?uri=' },
        { id: 'tronlink-app', name: 'TronLink App', icon: 'ğŸ”´', deepLink: 'tronlink://wc?uri=' },
        { id: 'okx-app', name: 'OKX App', icon: 'ğŸŸ¢', deepLink: 'okx://wc?uri=' },
        { id: 'bitget-app', name: 'Bitget', icon: 'ğŸ’¼', deepLink: 'bitget://wc?uri=' },
        { id: 'trust-app', name: 'Trust Wallet', icon: 'ğŸ›¡ï¸', deepLink: 'trust://wc?uri=' },
      ],
      cold: [
        { id: 'tronlink-scan', name: 'TronLink â€“ æƒæç™»å…¥', icon: 'ğŸ”´', action: 'scan' },
        { id: 'keystone', name: 'Keystone â€“ æƒæç™»å…¥', icon: 'ğŸ”', action: 'scan' },
        { id: 'safepal', name: 'SafePal â€“ æƒæç™»å…¥', icon: 'ğŸ¯', action: 'scan' },
        { id: 'onekey', name: 'OneKey â€“ æƒæç™»å…¥', icon: 'ğŸ”‘', action: 'scan' },
      ]
    };

    // é¡µé¢åˆ‡æ¢
    function showPage(pageId) {
      document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
      });
      document.getElementById(pageId).classList.add('active');
    }

    function showSelectorPage() {
      showPage('pageSelector');
      hideStatus();
    }

    function showQRPage() {
      showPage('pageQR');
      connectWalletConnect();
    }

    function showDeepLinkPage(wallet) {
      currentDeepLinkWallet = wallet;
      const page = document.getElementById('pageDeepLink');
      document.getElementById('deeplinkIcon').textContent = wallet.icon;
      document.getElementById('deeplinkTitle').textContent = `æ­£åœ¨æ‰“é–‹ ${wallet.name}â€¦`;
      document.getElementById('deeplinkButton').textContent = `æ‰“é–‹ ${wallet.name} App`;
      if (wallet.installUrl) {
        document.getElementById('deeplinkDownload').style.display = 'block';
        document.getElementById('deeplinkDownloadLink').href = wallet.installUrl;
      }
      showPage('pageDeepLink');
    }

    // çŠ¶æ€ç®¡ç†
    function updateStatus(type, message) {
      const statusDiv = document.getElementById('status');
      const statusText = document.getElementById('statusText');
      statusDiv.className = 'status ' + type;
      statusText.textContent = message;
      statusDiv.style.display = 'block';
    }

    function hideStatus() {
      document.getElementById('status').style.display = 'none';
    }

    // æ£€æµ‹å·²å®‰è£…çš„é’±åŒ…
    function getInstalledWallets() {
      const installed = {};
      WALLET_CONFIG.installed.forEach(wallet => {
        if (wallet.id === 'metamask' && window.ethereum?.isMetaMask) {
          installed[wallet.id] = true;
        } else if (wallet.id === 'coinbase' && window.ethereum?.isCoinbaseWallet) {
          installed[wallet.id] = true;
        } else if (wallet.id === 'okx' && window.okxwallet) {
          installed[wallet.id] = true;
        } else if (wallet.id === 'tronlink' && (window.tronWeb || window.tronLink)) {
          installed[wallet.id] = true;
        } else if (wallet.id === 'trust' && window.ethereum?.isTrust) {
          installed[wallet.id] = true;
        } else if (wallet.id === 'bitget' && window.bitkeep) {
          installed[wallet.id] = true;
        }
      });
      return installed;
    }

    // æ¸²æŸ“é’±åŒ…åˆ—è¡¨
    function renderWalletButton(wallet, isInstalled = false) {
      const button = document.createElement('button');
      button.className = 'wallet-button';
      button.onclick = () => handleWalletClick(wallet, isInstalled);
      
      button.innerHTML = `
        <div class="wallet-icon">${wallet.icon}</div>
        <div class="wallet-info">
          <div class="wallet-name">
            ${wallet.name}
            ${isInstalled ? '<span class="wallet-badge">å·²å®‰è£</span>' : ''}
          </div>
          ${wallet.type ? `<div class="wallet-type">${getWalletTypeText(wallet.type)}</div>` : ''}
        </div>
      `;
      
      return button;
    }

    function getWalletTypeText(type) {
      const types = {
        'extension': 'ç€è¦½å™¨æ“´å……åŠŸèƒ½',
        'tron': 'Tron éŒ¢åŒ…',
        'mobile': 'æ‰‹æ©ŸéŒ¢åŒ…',
        'cold': 'å†·éŒ¢åŒ…'
      };
      return types[type] || '';
    }

    // åˆå§‹åŒ–é’±åŒ…é€‰æ‹©å™¨
    function initWalletSelector() {
      const installed = getInstalledWallets();
      const installedList = WALLET_CONFIG.installed.filter(w => installed[w.id]);
      
      // æ¸²æŸ“å·²å®‰è£…çš„é’±åŒ…
      if (installedList.length > 0) {
        const installedSection = document.getElementById('installedWalletsSection');
        const installedListEl = document.getElementById('installedWalletsList');
        installedListEl.innerHTML = '';
        installedList.forEach(wallet => {
          installedListEl.appendChild(renderWalletButton(wallet, true));
        });
        installedSection.style.display = 'block';
      }

      // æ¸²æŸ“æ‰‹æœºé’±åŒ…
      const mobileSection = document.getElementById('mobileWalletsSection');
      const mobileListEl = document.getElementById('mobileWalletsList');
      mobileListEl.innerHTML = '';
      WALLET_CONFIG.mobile.forEach(wallet => {
        mobileListEl.appendChild(renderWalletButton(wallet));
      });
      mobileSection.style.display = 'block';

      // æ¸²æŸ“å†·é’±åŒ…
      const coldSection = document.getElementById('coldWalletsSection');
      const coldListEl = document.getElementById('coldWalletsList');
      coldListEl.innerHTML = '';
      WALLET_CONFIG.cold.forEach(wallet => {
        coldListEl.appendChild(renderWalletButton(wallet));
      });
      coldSection.style.display = 'block';
    }

    // å¤„ç†é’±åŒ…ç‚¹å‡»
    async function handleWalletClick(wallet, isInstalled) {
      try {
        // å·²å®‰è£…çš„é’±åŒ… - ç›´æ¥è¿æ¥
        if (isInstalled) {
          if (wallet.type === 'tron') {
            await connectTronLink();
          } else if (wallet.type === 'extension') {
            ethereumProvider = window.ethereum;
            isBrowserExtension = true;
            await connectBrowserExtension();
          }
        }
        // æ‰‹æœºé’±åŒ… - Deep Link
        else if (wallet.deepLink) {
          showDeepLinkPage(wallet);
          // ç­‰å¾… WalletConnect URI ç”Ÿæˆ
          await connectWalletConnect();
        }
        // å†·é’±åŒ… - æ˜¾ç¤º QR Code
        else if (wallet.action === 'scan') {
          showQRPage();
        }
      } catch (error) {
        debugError('è™•ç†éŒ¢åŒ…é»æ“Šå¤±æ•—:', error);
        updateStatus('error', 'é€£æ¥å¤±æ•—: ' + error.message);
      }
    }

    // æ‰“å¼€ Deep Link
    async function openDeepLinkApp() {
      if (currentDeepLinkWallet && currentUri) {
        const deepLink = currentDeepLinkWallet.deepLink + encodeURIComponent(currentUri);
        window.location.href = deepLink;
        
        // è®¾ç½®è¶…æ—¶ï¼Œå¦‚æœ5ç§’åè¿˜æ²¡è·³è½¬ï¼Œæ˜¾ç¤ºä¸‹è½½é“¾æ¥
        setTimeout(() => {
          document.getElementById('deeplinkDownload').style.display = 'block';
        }, 5000);
      }
    }

    // åˆ·æ–° QR Code
    async function refreshQRCode() {
      if (signClient && currentUri) {
        // æ–­å¼€å½“å‰è¿æ¥
        try {
          const sessions = signClient.session.getAll();
          sessions.forEach(s => {
            if (s.topic) {
              signClient.disconnect({ topic: s.topic, reason: { code: 6000, message: 'User refreshed QR' } });
            }
          });
        } catch (e) {
          debugWarn('æ–­å¼€è¿æ¥å¤±è´¥:', e);
        }
        
        // é‡æ–°ç”Ÿæˆ QR Code
        await connectWalletConnect();
      }
    }

    // WalletConnect ç›¸å…³å‡½æ•°ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
    async function waitForSignClient() {
      return new Promise((resolve, reject) => {
        const checkSignClient = () => {
          try {
            const wcModule = window['@walletconnect/sign-client'];
            if (wcModule) {
              SignClient = wcModule.SignClient || wcModule.default || wcModule;
              if (SignClient && typeof SignClient.init === 'function') {
                return SignClient;
              }
            }
            return null;
          } catch (e) {
            debugError('æ£€æŸ¥ SignClient æ—¶å‡ºé”™:', e);
            return null;
          }
        };

        const client = checkSignClient();
        if (client) {
          resolve(client);
          return;
        }

        let attempts = 0;
        const maxAttempts = 100;
        const checkInterval = setInterval(() => {
          attempts++;
          const client = checkSignClient();
          if (client) {
            clearInterval(checkInterval);
            resolve(client);
          } else if (attempts >= maxAttempts) {
            clearInterval(checkInterval);
            reject(new Error('WalletConnect SignClient åŠ è½½è¶…æ—¶'));
          }
        }, 100);
      });
    }

    async function initWalletConnect() {
      try {
        await waitForSignClient();
        
        if (!SignClient) {
          throw new Error('SignClient æœªæ‰¾åˆ°');
        }
        
        signClient = await SignClient.init({
          projectId: CONFIG.projectId,
          metadata: {
            name: 'Agora Market',
            description: 'Agora Market DApp',
            url: window.location.origin,
            icons: [window.location.origin + '/favicon.png']
          }
        });

        setupSessionListeners();
      } catch (error) {
        debugError('WalletConnect åˆå§‹åŒ–å¤±è´¥:', error);
        throw error;
      }
    }

    function setupSessionListeners() {
      if (!signClient) return;

      signClient.on('session_update', ({ topic, params }) => {
        if (session && session.topic === topic) {
          session = { ...session, ...params };
          const walletAddress = getWalletAddress();
          if (walletAddress) {
            sendEventToFlutter('session_updated', {
              walletAddress: walletAddress,
              session: session
            });
          }
        }
      });

      signClient.on('session_delete', ({ topic }) => {
        if (session && session.topic === topic) {
          session = null;
          sendEventToFlutter('session_disconnected', {});
        }
      });
    }

    async function connectWalletConnect() {
      try {
        if (!signClient) {
          updateStatus('info', 'æ­£åœ¨åˆå§‹åŒ– WalletConnect...');
          await initWalletConnect();
          
          if (!signClient) {
            throw new Error('WalletConnect åˆå§‹åŒ–å¤±æ•—');
          }
        }

        updateStatus('info', 'æ­£åœ¨ç”Ÿæˆé€£æ¥è«‹æ±‚...');

        const { uri, approval } = await signClient.connect({
          requiredNamespaces: {
            eip155: {
              methods: ['personal_sign', 'eth_signTypedData'],
              chains: CONFIG.supportedChains,
              events: ['chainChanged', 'accountsChanged']
            }
          }
        });

        if (uri) {
          currentUri = uri;
          await showQRCode(uri);
          sendEventToFlutter('uri_generated', { uri: uri });
          
          // è®¾ç½® QR è¿‡æœŸå€’è®¡æ—¶
          startQRExpiryTimer();
        } else {
          throw new Error('æœªèƒ½ç”Ÿæˆé€£æ¥ URI');
        }

        // ç­‰å¾…ç”¨æˆ·æ‰¹å‡†è¿æ¥
        updateStatus('info', 'ç­‰å¾…éŒ¢åŒ…é€£æ¥...');
        session = await approval();

        const walletAddress = getWalletAddress();
        if (walletAddress) {
          updateStatus('success', 'éŒ¢åŒ…é€£æ¥æˆåŠŸï¼');
          showWalletInfo(walletAddress);
          sendEventToFlutter('connected', { 
            walletAddress: walletAddress,
            session: session,
            isBrowserExtension: false
          });

          await performLogin(walletAddress);
        }
      } catch (error) {
        debugError('é€£æ¥ WalletConnect å¤±æ•—:', error);
        if (error.message && (error.message.includes('User rejected') || error.message.includes('rejected'))) {
          updateStatus('info', 'å·²å–æ¶ˆé€£æ¥');
          showSelectorPage();
          return;
        }
        updateStatus('error', 'é€£æ¥å¤±æ•—: ' + error.message);
        sendEventToFlutter('error', { error: error.message });
      }
    }

    async function showQRCode(uri) {
      const qrcodeDiv = document.getElementById('qrcode');
      qrcodeDiv.innerHTML = '';
      
      try {
        const qrcode = new QRCode(qrcodeDiv, {
          text: uri,
          width: 220,
          height: 220,
          colorDark: '#000000',
          colorLight: '#FFFFFF',
          correctLevel: QRCode.CorrectLevel.H
        });
      } catch (error) {
        debugError('ç”Ÿæˆ QR Code å¤±è´¥:', error);
        qrcodeDiv.innerHTML = '<p>ç„¡æ³•ç”Ÿæˆ QR Code</p>';
      }
    }

    function startQRExpiryTimer() {
      if (qrRefreshTimer) {
        clearInterval(qrRefreshTimer);
      }
      
      let seconds = 120;
      const expiryEl = document.getElementById('qrExpiry');
      
      qrRefreshTimer = setInterval(() => {
        seconds--;
        if (seconds > 0) {
          expiryEl.textContent = `æ­¤ QR å°‡åœ¨ ${Math.floor(seconds / 60)} åˆ† ${seconds % 60} ç§’å¾ŒéæœŸ`;
        } else {
          expiryEl.textContent = 'QR Code å·²éæœŸï¼Œè«‹é»æ“Šé‡æ–°æ•´ç†';
          clearInterval(qrRefreshTimer);
        }
      }, 1000);
    }

    function getWalletAddress() {
      if (!session || !session.namespaces || !session.namespaces.eip155) {
        return null;
      }
      const accounts = session.namespaces.eip155.accounts;
      if (accounts && accounts.length > 0) {
        return accounts[0].split(':')[2];
      }
      return null;
    }

    function showWalletInfo(address) {
      const walletInfo = document.getElementById('walletInfo');
      const walletAddress = document.getElementById('walletAddress');
      walletInfo.style.display = 'block';
      walletAddress.textContent = address;
    }

    // è¿æ¥ TronLink
    async function connectTronLink() {
      try {
        if (window.tronWeb) {
          tronWeb = window.tronWeb;
        } else if (window.tronLink && window.tronLink.tronWeb) {
          tronWeb = window.tronLink.tronWeb;
        } else {
          throw new Error('æœªæª¢æ¸¬åˆ° TronLink');
        }

        updateStatus('info', 'æ­£åœ¨é€£æ¥ TronLink...');
        isTronLink = true;

        if (!tronWeb || !tronWeb.ready) {
          await new Promise((resolve) => setTimeout(resolve, 1000));
          if (window.tronWeb) {
            tronWeb = window.tronWeb;
          } else if (window.tronLink && window.tronLink.tronWeb) {
            tronWeb = window.tronLink.tronWeb;
          }
        }

        if (!tronWeb || !tronWeb.ready) {
          throw new Error('TronLink æœªå°±ç·’');
        }

        let account = tronWeb.defaultAddress?.base58;
        
        if (!account) {
          try {
            await tronWeb.request({
              method: 'tron_requestAccounts'
            });
          } catch (e) {
            debugWarn('TronLink request å¤±è´¥:', e);
          }
          
          account = tronWeb.defaultAddress?.base58;
          if (!account) {
            throw new Error('ç”¨æˆ¶æ‹’çµ•é€£æ¥');
          }
        }

        const walletAddress = account;
        updateStatus('success', 'éŒ¢åŒ…é€£æ¥æˆåŠŸï¼');
        showWalletInfo(walletAddress);
        
        sendEventToFlutter('connected', { 
          walletAddress: walletAddress,
          isTronLink: true,
          chain: 'TRC20'
        });

        await performLogin(walletAddress);
      } catch (error) {
        debugError('é€£æ¥ TronLink å¤±æ•—:', error);
        if (error.code === 4001 || error.message.includes('rejected') || error.message.includes('denied')) {
          updateStatus('info', 'å·²å–æ¶ˆé€£æ¥');
          return;
        }
        updateStatus('error', 'é€£æ¥å¤±æ•—: ' + error.message);
        sendEventToFlutter('error', { error: error.message });
      }
    }

    // è¿æ¥æµè§ˆå™¨æ‰©å±•
    async function connectBrowserExtension() {
      try {
        if (!ethereumProvider) {
          throw new Error('æœªæª¢æ¸¬åˆ°ç€è¦½å™¨æ“´å……åŠŸèƒ½');
        }

        updateStatus('info', 'æ­£åœ¨é€£æ¥ç€è¦½å™¨æ“´å……åŠŸèƒ½...');
        isBrowserExtension = true;

        const accounts = await ethereumProvider.request({
          method: 'eth_requestAccounts'
        });

        if (!accounts || accounts.length === 0) {
          throw new Error('ç”¨æˆ¶æ‹’çµ•é€£æ¥');
        }

        const walletAddress = accounts[0];
        updateStatus('success', 'éŒ¢åŒ…é€£æ¥æˆåŠŸï¼');
        showWalletInfo(walletAddress);
        
        sendEventToFlutter('connected', { 
          walletAddress: walletAddress,
          isBrowserExtension: true
        });

        await performLogin(walletAddress);
      } catch (error) {
        debugError('é€£æ¥ç€è¦½å™¨æ“´å……åŠŸèƒ½å¤±æ•—:', error);
        if (error.code === 4001 || error.message.includes('rejected') || error.message.includes('denied')) {
          updateStatus('info', 'å·²å–æ¶ˆé€£æ¥');
          return;
        }
        updateStatus('error', 'é€£æ¥å¤±æ•—: ' + error.message);
        sendEventToFlutter('error', { error: error.message });
      }
    }

    // ç™»å½•æµç¨‹ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
    async function performLogin(walletAddress) {
      try {
        updateStatus('info', 'æ­¥é©Ÿ 1/4: ç²å–é©—è­‰ä¿¡æ¯');
        
        const nonceData = await getNonce(walletAddress);
        updateStatus('info', 'æ­¥é©Ÿ 2/4: ç°½åæ¶ˆæ¯');
        const signature = await signMessage(nonceData, walletAddress);
        updateStatus('info', 'æ­¥é©Ÿ 3/4: é©—è­‰ç™»éŒ„');
        const loginData = await verifyAndLogin(walletAddress, signature, nonceData);
        await handleLoginSuccess(loginData);
      } catch (error) {
        handleLoginError(error);
      }
    }

    async function getNonce(walletAddress) {
      const nonceResponse = await fetch(`${CONFIG.apiBaseUrl}/auth/wallet-connect/nonce`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          walletAddress: walletAddress
        })
      });

      if (!nonceResponse.ok) {
        throw new Error('ç²å– nonce å¤±æ•—: ' + nonceResponse.statusText);
      }

      const data = await nonceResponse.json();
      
      if (data.message && (!data.nonce || data.nonce === '')) {
        if (data.message.includes('Nonce:')) {
          const nonceMatch = data.message.match(/Nonce:\s*([^\n]+)/);
          if (nonceMatch && nonceMatch[1]) {
            data.nonce = nonceMatch[1].trim();
          }
        }
      }
      
      if (data.message && !data.timestamp) {
        if (data.message.includes('Timestamp:')) {
          const timestampMatch = data.message.match(/Timestamp:\s*([^\n]+)/);
          if (timestampMatch && timestampMatch[1]) {
            const timestamp = parseInt(timestampMatch[1].trim());
            if (!isNaN(timestamp)) {
              data.timestamp = timestamp;
            }
          }
        }
      }
      
      if (!data.message || data.message === '') {
        throw new Error('ç²å– nonce å¤±æ•—ï¼šç¼ºå°‘ message å­—æ®µ');
      }
      
      if (!data.nonce || data.nonce === '') {
        throw new Error('ç²å– nonce å¤±æ•—ï¼šç¼ºå°‘ nonce å­—æ®µ');
      }
      
      if (!data.timestamp) {
        data.timestamp = Math.floor(Date.now() / 1000);
      }

      sendEventToFlutter('nonce_received', { nonce: data.nonce });
      return data;
    }

    async function signMessage(nonceData, walletAddress) {
      updateStatus('info', 'è«‹åœ¨éŒ¢åŒ…ä¸­ç°½åæ¶ˆæ¯...');

      if (isTronLink && tronWeb) {
        return await signWithTronLink(nonceData);
      } else if (isBrowserExtension && ethereumProvider) {
        return await signWithBrowserExtension(nonceData);
      } else {
        return await signWithWalletConnect(nonceData);
      }
    }

    async function signWithBrowserExtension(nonceData) {
      try {
        const accounts = await ethereumProvider.request({ method: 'eth_accounts' });
        if (!accounts || accounts.length === 0) {
          throw new Error('æœªæ‰¾åˆ°é€£æ¥çš„å¸³æˆ¶');
        }
        
        const account = accounts[0];
        const signPromise = ethereumProvider.request({
          method: 'personal_sign',
          params: [nonceData.message, account]
        });
        
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            reject(new Error('ç°½åè«‹æ±‚è¶…æ™‚ï¼ˆ60ç§’ï¼‰'));
          }, 60000);
        });
        
        const signature = await Promise.race([signPromise, timeoutPromise]);
        return signature;
      } catch (signError) {
        if (signError.code === 4001 || 
            signError.message?.includes('rejected') || 
            signError.message?.includes('denied') || 
            signError.message?.includes('User rejected')) {
          updateStatus('info', 'ç°½åå·²å–æ¶ˆ');
          sendEventToFlutter('error', { error: 'ç”¨æˆ¶å–æ¶ˆç°½å' });
          throw new Error('USER_CANCELLED');
        }
        debugError('âŒ æµè§ˆå™¨æ‰©å±•ç­¾åå¤±è´¥:', signError);
        throw signError;
      }
    }

    async function signWithTronLink(nonceData) {
      try {
        if (!tronWeb || !tronWeb.ready) {
          throw new Error('TronLink æœªå°±ç·’');
        }

        const account = tronWeb.defaultAddress?.base58;
        const canUseSignMessageV2 = tronWeb.trx && typeof tronWeb.trx.signMessageV2 === 'function';
        
        let signature;
        if (canUseSignMessageV2) {
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              reject(new Error('ç°½åè«‹æ±‚è¶…æ™‚ï¼ˆ60ç§’ï¼‰'));
            }, 60000);
          });
          
          const signPromise = tronWeb.trx.signMessageV2(nonceData.message);
          const result = await Promise.race([signPromise, timeoutPromise]);
          
          signature = result.signature || result;
          
          if (typeof signature === 'object' && signature !== null) {
            signature = signature.signature || signature.result || JSON.stringify(signature);
          }
          
          if (typeof signature !== 'string') {
            signature = String(signature);
          }
          
          if (signature && !signature.startsWith('0x') && /^[0-9a-fA-F]+$/.test(signature)) {
            signature = '0x' + signature;
          }
        } else if (tronWeb.request) {
          const result = await tronWeb.request({
            method: 'tron_signMessage',
            params: {
              message: nonceData.message,
              address: account
            }
          });
          signature = result.signature || result;
          if (signature && typeof signature === 'string' && !signature.startsWith('0x')) {
            signature = '0x' + signature;
          }
        } else {
          throw new Error('TronLink ç°½åæ–¹æ³•ä¸å¯ç”¨');
        }
        
        return signature;
      } catch (signError) {
        if (signError.code === 4001 || 
            signError.message?.includes('rejected') || 
            signError.message?.includes('denied') || 
            signError.message?.includes('User rejected') ||
            signError.message?.includes('User cancel') ||
            signError.message?.includes('cancelled')) {
          updateStatus('info', 'ç°½åå·²å–æ¶ˆ');
          sendEventToFlutter('error', { error: 'ç”¨æˆ¶å–æ¶ˆç°½å' });
          throw new Error('USER_CANCELLED');
        }
        debugError('âŒ TronLink ç­¾åå¤±è´¥:', signError);
        throw signError;
      }
    }

    async function signWithWalletConnect(nonceData) {
      let chainId = 'eip155:1';
      const availableChains = session.namespaces.eip155.chains || [];
      
      if (availableChains.includes('eip155:1')) {
        chainId = 'eip155:1';
      } else if (availableChains.includes('eip155:56')) {
        chainId = 'eip155:56';
      } else if (availableChains.length > 0) {
        chainId = availableChains[0];
      }
      
      const account = session.namespaces.eip155.accounts[0];
      
      try {
        const signature = await signClient.request({
          topic: session.topic,
          chainId: chainId,
          request: {
            method: 'personal_sign',
            params: [nonceData.message, account]
          }
        });
        return signature;
      } catch (signError) {
        debugError('âŒ WalletConnect ç­¾åå¤±è´¥:', signError);
        throw signError;
      }
    }

    async function verifyAndLogin(walletAddress, signature, nonceData) {
      updateStatus('info', 'ç°½åæˆåŠŸï¼Œæ­£åœ¨é©—è­‰...');
      
      sendEventToFlutter('signature_received', {
        signature: signature,
        walletAddress: walletAddress
      });
      
      const requestBody = {
        walletAddress: walletAddress,
        signature: signature,
        nonce: nonceData.nonce,
        timestamp: nonceData.timestamp
      };
      
      if (isTronLink) {
        requestBody.chain = 'TRC20';
        requestBody.chainType = 'tron';
      }
      
      const loginResponse = await fetch(`${CONFIG.apiBaseUrl}/auth/wallet-connect/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!loginResponse.ok) {
        const errorData = await loginResponse.json().catch(() => ({ message: loginResponse.statusText }));
        debugError('âŒ ç™»å½•å¤±è´¥:', errorData);
        throw new Error(errorData.message || 'ç™»éŒ„å¤±æ•—: ' + loginResponse.statusText);
      }

      const loginData = await loginResponse.json();
      
      if (!loginData.token || !loginData.refreshToken) {
        debugError('âŒ ç™»å½•å“åº”ä¸­ç¼ºå°‘ token');
        throw new Error(loginData.message || 'ç™»éŒ„éŸ¿æ‡‰ä¸­ç¼ºå°‘ token');
      }

      return loginData;
    }

    async function handleLoginSuccess(loginData) {
      updateStatus('success', 'ç™»å…¥æˆåŠŸï¼');
      
      sendEventToFlutter('verified', {
        token: loginData.token,
        refreshToken: loginData.refreshToken,
        user: loginData.user
      });
    }

    function handleLoginError(error) {
      if (error.message === 'USER_CANCELLED') {
        return;
      }
      
      debugError('âŒ ç™»å½•å¤±è´¥:', error);
      
      const userFriendlyMessages = {
        'timeout': 'æ“ä½œè¶…æ—¶ï¼Œè¯·é‡è¯•',
        'network': 'ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥',
        'User rejected': 'æ‚¨å·²å–æ¶ˆæ“ä½œ'
      };
      
      const message = userFriendlyMessages[error.message] || error.message || 'å‘ç”ŸæœªçŸ¥é”™è¯¯';
      updateStatus('error', 'ç™»éŒ„å¤±æ•—: ' + message);
      sendEventToFlutter('error', { error: message });
    }

    function sendEventToFlutter(event, data) {
      try {
        const isInIframe = window.self !== window.top;
        
        if (isInIframe && window.parent && window.parent.postMessage) {
          window.parent.postMessage({
            event: event,
            data: data
          }, window.location.origin);
        } else if (window.flutter_inappwebview && window.flutter_inappwebview.callHandler) {
          window.flutter_inappwebview.callHandler('walletConnectEvent', {
            event: event,
            data: data
          });
        } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.walletConnectEvent) {
          window.webkit.messageHandlers.walletConnectEvent.postMessage({
            event: event,
            data: data
          });
        }
      } catch (error) {
        debugError('âŒ å‘é€äº‹ä»¶åˆ° Flutter å¤±è´¥:', error);
      }
    }

    // åˆå§‹åŒ–
    async function init() {
      try {
        updateStatus('info', 'æ­£åœ¨æª¢æ¸¬å¯ç”¨éŒ¢åŒ…...');
        
        // åˆå§‹åŒ– WalletConnectï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡ï¼‰
        initWalletConnect().catch(() => {
          // é™é»˜å¤„ç†é”™è¯¯
        });
        
        // åˆå§‹åŒ–é’±åŒ…é€‰æ‹©å™¨
        initWalletSelector();
        
        hideStatus();
      } catch (error) {
        debugError('åˆå§‹åŒ–å¤±è´¥:', error);
        updateStatus('error', 'åˆå§‹åŒ–å¤±è´¥: ' + error.message);
        sendEventToFlutter('error', { error: error.message });
      }
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', async () => {
      await init();
    });

    // é”™è¯¯å¤„ç†
    window.addEventListener('error', (event) => {
      debugError('å…¨å±€é”™è¯¯:', event.error);
      updateStatus('error', 'ç™¼ç”ŸéŒ¯èª¤: ' + (event.error?.message || 'æœªçŸ¥éŒ¯èª¤'));
      sendEventToFlutter('error', { error: event.error?.message || 'æœªçŸ¥éŒ¯èª¤' });
    });

    window.addEventListener('unhandledrejection', (event) => {
      debugError('æœªå¤„ç†çš„ Promise æ‹’ç»:', event.reason);
      updateStatus('error', 'ç™¼ç”ŸéŒ¯èª¤: ' + (event.reason?.message || 'æœªçŸ¥éŒ¯èª¤'));
      sendEventToFlutter('error', { error: event.reason?.message || 'æœªçŸ¥éŒ¯èª¤' });
    });
  </script>
</body>
</html>
